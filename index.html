<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Work in Progress</title>
  <style>
    :root{
      --bg: #f3efe6;
      --ink: #151312;
      --muted: rgba(21,19,18,.65);
      --card: rgba(255,255,255,.35);
      --stroke: rgba(21,19,18,.9);
      --strokeSoft: rgba(21,19,18,.35);
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      height:100vh;
      background: radial-gradient(1200px 800px at 20% 20%, rgba(0,0,0,.06), transparent 60%),
                  radial-gradient(900px 700px at 80% 70%, rgba(0,0,0,.05), transparent 60%),
                  var(--bg);
      color:var(--ink);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      overflow:hidden;
    }

    .wrap{
      position:relative;
      height:100%;
      display:grid;
      place-items:center;
      padding:24px;
    }

    .frame{
      width:min(980px, 95vw);
      height:min(560px, 72vh);
      border:1px solid rgba(21,19,18,.18);
      border-radius:24px;
      background: linear-gradient(180deg, rgba(255,255,255,.45), rgba(255,255,255,.18));
      box-shadow: 0 24px 80px rgba(0,0,0,.14);
      backdrop-filter: blur(10px);
      position:relative;
      overflow:hidden;
    }

    .header{
      position:absolute;
      inset:24px 24px auto 24px;
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:16px;
      pointer-events:none;
    }

    .title{
      pointer-events:auto;
      user-select:none;
      display:flex;
      flex-direction:column;
      gap:8px;
    }

    .title h1{
      margin:0;
      font-size: clamp(24px, 3.2vw, 42px);
      letter-spacing:-0.02em;
      line-height:1.05;
    }
    .title p{
      margin:0;
      font-size: 14px;
      color: var(--muted);
      max-width: 52ch;
    }

    .badge{
      pointer-events:none;
      user-select:none;
      font-size:12px;
      letter-spacing:.12em;
      text-transform:uppercase;
      color:var(--muted);
      border:1px solid rgba(21,19,18,.18);
      padding:10px 12px;
      border-radius:999px;
      background: rgba(255,255,255,.32);
    }

    canvas{
      width:100%;
      height:100%;
      display:block;
    }

    .hint{
      position:absolute;
      left:24px;
      bottom:22px;
      display:flex;
      gap:10px;
      align-items:center;
      font-size:12px;
      color:var(--muted);
      pointer-events:none;
      user-select:none;
    }
    .dot{
      width:8px;height:8px;border-radius:50%;
      background: rgba(21,19,18,.35);
      box-shadow: 0 0 0 6px rgba(21,19,18,.06);
    }

    .footer{
      position:absolute;
      right:24px;
      bottom:18px;
      font-size:12px;
      color:rgba(21,19,18,.45);
      pointer-events:none;
      user-select:none;
      text-align:right;
    }

    /* Tiny flourish: subtle noise */
    .noise{
      position:absolute; inset:-40px;
      background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='120' height='120'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.8' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='120' height='120' filter='url(%23n)' opacity='.22'/%3E%3C/svg%3E");
      opacity:.06;
      mix-blend-mode:multiply;
      pointer-events:none;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="frame" id="frame">
      <canvas id="c"></canvas>
      <div class="noise"></div>

      <div class="header">
        <div class="title">
          <h1>Work in Progress</h1>
          <p>Website coming soon. In the meantime: pull the line until it snaps. Yes, this is science.</p>
        </div>
        <div class="badge">COMING SOON</div>
      </div>

      <div class="hint">
        <span class="dot"></span>
        <span>Hover / drag to add tension · cross the threshold to release</span>
      </div>

      <div class="footer">
        <div id="readout">tension: 0%</div>
      </div>
    </div>
  </div>

  <script>
    (() => {
      const canvas = document.getElementById('c');
      const frame = document.getElementById('frame');
      const readout = document.getElementById('readout');
      const ctx = canvas.getContext('2d');

      // HiDPI sizing
      function resize() {
        const r = frame.getBoundingClientRect();
        const dpr = Math.max(1, Math.min(2.5, window.devicePixelRatio || 1));
        canvas.width = Math.floor(r.width * dpr);
        canvas.height = Math.floor(r.height * dpr);
        canvas.style.width = r.width + 'px';
        canvas.style.height = r.height + 'px';
        ctx.setTransform(dpr,0,0,dpr,0,0);
      }
      window.addEventListener('resize', resize, { passive:true });
      resize();

      // Line anchored left/right with a draggable "pull" point near center
      let mouse = { x: 0, y: 0, down: false, inside: false };
      let pull = { x: 0, y: 0, vx: 0, vy: 0 };    // spring point
      let base = { x: 0, y: 0 };                  // neutral center point

      // Physics knobs (tweakable)
      const k = 0.08;     // spring stiffness
      const damp = 0.82;  // damping
      const snapThreshold = 130; // px distance to trigger snap
      const snapKick = 18; // impulse on snap

      // Visual knobs
      const lineWidth = 2.0;
      const glowWidth = 18;

      function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
      function len(x,y){ return Math.hypot(x,y); }

      function layout() {
        const w = frame.clientWidth;
        const h = frame.clientHeight;
        base.x = w * 0.5;
        base.y = h * 0.62;
        // Initialize pull at base if first time
        if (!pull.x && !pull.y) {
          pull.x = base.x;
          pull.y = base.y;
        }
      }
      layout();
      window.addEventListener('resize', layout, { passive:true });

      function pointerPos(e){
        const r = frame.getBoundingClientRect();
        return {
          x: e.clientX - r.left,
          y: e.clientY - r.top
        };
      }

      frame.addEventListener('pointerenter', () => { mouse.inside = true; }, { passive:true });
      frame.addEventListener('pointerleave', () => { mouse.inside = false; mouse.down = false; }, { passive:true });
      frame.addEventListener('pointerdown', (e) => {
        mouse.down = true;
        const p = pointerPos(e);
        mouse.x = p.x; mouse.y = p.y;
        frame.setPointerCapture(e.pointerId);
      });
      frame.addEventListener('pointerup', () => { mouse.down = false; });
      frame.addEventListener('pointermove', (e) => {
        const p = pointerPos(e);
        mouse.x = p.x; mouse.y = p.y;
      }, { passive:true });

      // A subtle “breathing” background grid
      function drawGrid(w,h,t){
        ctx.save();
        ctx.globalAlpha = 0.09;
        const step = 28;
        const wobble = 2.5 * Math.sin(t*0.001);
        ctx.lineWidth = 1;
        ctx.strokeStyle = 'rgba(21,19,18,.35)';
        for(let x=0; x<=w; x+=step){
          ctx.beginPath();
          ctx.moveTo(x + wobble, 0);
          ctx.lineTo(x - wobble, h);
          ctx.stroke();
        }
        ctx.globalAlpha = 0.06;
        for(let y=0; y<=h; y+=step){
          ctx.beginPath();
          ctx.moveTo(0, y - wobble);
          ctx.lineTo(w, y + wobble);
          ctx.stroke();
        }
        ctx.restore();
      }

      function tick(t){
        const w = frame.clientWidth;
        const h = frame.clientHeight;

        // Target follows mouse when inside (stronger when mouse is down)
        const influence = mouse.inside ? (mouse.down ? 1.0 : 0.55) : 0.0;
        const targetX = base.x + (mouse.x - base.x) * influence;
        const targetY = base.y + (mouse.y - base.y) * influence;

        // Spring force toward target, but "wants" to return to base when not interacting
        const goalX = influence > 0 ? targetX : base.x;
        const goalY = influence > 0 ? targetY : base.y;

        // Physics update
        const ax = (goalX - pull.x) * k;
        const ay = (goalY - pull.y) * k;
        pull.vx = (pull.vx + ax) * damp;
        pull.vy = (pull.vy + ay) * damp;
        pull.x += pull.vx;
        pull.y += pull.vy;

        // Compute tension based on distance from base
        const dx = pull.x - base.x;
        const dy = pull.y - base.y;
        const dist = len(dx,dy);
        const tension01 = clamp(dist / snapThreshold, 0, 1);
        readout.textContent = `tension: ${Math.round(tension01*100)}%`;

        // Snap + bounce when crossing threshold while interacting (hover OR drag)
        // Cool detail: it only triggers when moving outward (so it doesn't spam).
        const movingOut = (dx*pull.vx + dy*pull.vy) > 0;
        if (influence > 0 && movingOut && dist > snapThreshold) {
          // Kick back toward base with an impulse proportional to overshoot
          const overshoot = dist - snapThreshold;
          const nx = dx / (dist || 1);
          const ny = dy / (dist || 1);
          pull.vx -= nx * (snapKick + overshoot * 0.08);
          pull.vy -= ny * (snapKick + overshoot * 0.08);
        }

        // Draw
        ctx.clearRect(0,0,w,h);
        drawGrid(w,h,t);

        // Anchors
        const left = { x: w*0.12, y: h*0.62 };
        const right = { x: w*0.88, y: h*0.62 };

        // Control points for a smooth curve
        const c1 = { x: (left.x + pull.x)*0.5, y: (left.y + pull.y)*0.5 };
        const c2 = { x: (right.x + pull.x)*0.5, y: (right.y + pull.y)*0.5 };

        // Glow (soft)
        ctx.save();
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.globalAlpha = 0.18 + tension01*0.24;
        ctx.lineWidth = glowWidth;
        ctx.strokeStyle = 'rgba(21,19,18,.35)';
        ctx.beginPath();
        ctx.moveTo(left.x, left.y);
        ctx.bezierCurveTo(c1.x, c1.y, c2.x, c2.y, right.x, right.y);
        ctx.stroke();
        ctx.restore();

        // Main line
        ctx.save();
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.lineWidth = lineWidth;
        ctx.strokeStyle = 'rgba(21,19,18,.92)';
        ctx.beginPath();
        ctx.moveTo(left.x, left.y);
        ctx.bezierCurveTo(c1.x, c1.y, c2.x, c2.y, right.x, right.y);
        ctx.stroke();
        ctx.restore();

        // End caps + pull node
        function node(x,y,r,alpha){
          ctx.save();
          ctx.globalAlpha = alpha;
          ctx.beginPath();
          ctx.arc(x,y,r,0,Math.PI*2);
          ctx.fillStyle = 'rgba(21,19,18,.92)';
          ctx.fill();
          ctx.restore();
        }
        node(left.x,left.y,3.2,0.9);
        node(right.x,right.y,3.2,0.9);

        // Pull node ring shows tension
        ctx.save();
        ctx.beginPath();
        ctx.arc(pull.x,pull.y,9,0,Math.PI*2);
        ctx.strokeStyle = 'rgba(21,19,18,.55)';
        ctx.lineWidth = 1.2;
        ctx.stroke();
        ctx.restore();

        node(pull.x,pull.y,3.0,0.95);

        // Little "danger" marker near threshold
        const warnX = base.x;
        const warnY = base.y - snapThreshold*0.6;
        ctx.save();
        ctx.globalAlpha = 0.12;
        ctx.beginPath();
        ctx.arc(base.x, base.y, snapThreshold, 0, Math.PI*2);
        ctx.strokeStyle = 'rgba(21,19,18,.35)';
        ctx.setLineDash([6,8]);
        ctx.lineWidth = 1;
        ctx.stroke();
        ctx.restore();

        requestAnimationFrame(tick);
      }
      requestAnimationFrame(tick);
    })();
  </script>
</body>
</html>
